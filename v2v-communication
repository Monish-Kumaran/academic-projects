//--------------------------------TRANSMITTER---------------------------------------//
#include <WiFi.h> 
#include <WiFiUDP.h> 
#include <TinyGPS++.h> 
#include <HardwareSerial.h> 
#include <Wire.h> 
#include <Adafruit_MPU6050.h> 
#include <Adafruit_Sensor.h> 
// 
Wi-Fi Setup 
const char* ssid = "Monish's Galaxy M14 5G"; 
const char* password = "MONISH@2004"; 
const char* receiverIP = "192.168.4.2"; // IP of the receiver ESP32 
const int udpPort = 4210; 
WiFiUDP udp; 

//---------GPS setup-------
TinyGPSPlus gps;
HardwareSerial SerialGPS(1); // use UART1
#define GPS_RX 16 
#define GPS_TX 17 
// ----------- MPU6050 Setup ----------- 
Adafruit_MPU6050 mpu; 
float accelThreshold = -2.0; // Adjust to detect braking
// 
Setup 
void setup() { 
Serial.begin(115200); 
// GPS Serial 
SerialGPS.begin(9600, SERIAL_8N1, GPS_RX, GPS_TX); 
// MPU6050 
Wire.begin(); 
if (!mpu.begin()) { 
Serial.println("Failed to find MPU6050 chip"); 
while (1); 
} 
mpu.setAccelerometerRange(MPU6050_RANGE_8_G); 
mpu.setFilterBandwidth(MPU6050_BAND_5_HZ); 
// Wi-Fi 
WiFi.begin(ssid, password); 
Serial.print("Connecting to WiFi"); 
while (WiFi.status() != WL_CONNECTED) { 
delay(500); Serial.print("."); 
} 
Serial.println("\nConnected to WiFi"); 
} 
// 
Main Loop 
void loop() { 
// ----- Read GPS ----- 
while (SerialGPS.available() > 0) { 
gps.encode(SerialGPS.read()); 
} 
float latitude = gps.location.isValid() ? gps.location.lat() : 0.0; 
float longitude = gps.location.isValid() ? gps.location.lng() : 0.0; 
float speed = gps.speed.kmph(); 
// ----- Read MPU6050 ----- 
sensors_event_t a, g, temp; 
mpu.getEvent(&a, &g, &temp); 
// Check for braking (negative acceleration on X-axis) 
bool isBraking = (a.acceleration.x < accelThreshold); 
// ----- Format and Send Data ----- 
String message = "{"; 
message += "\"lat\":" + String(latitude, 6) + ","; 
message += "\"lon\":" + String(longitude, 6) + ","; 
message += "\"speed\":" + String(speed, 2) + ","; 
message += "\"brake\":" + String(isBraking ? "true" : "false"); 
message += "}"; 
// Send via UDP 
udp.beginPacket(receiverIP, udpPort); 
udp.print(message); 
udp.endPacket(); 
Serial.println("Sent: " + message); 
delay(500); // Send every 500 ms 
} 

//--------------------------------------RECEIVER---------------------------------------//

#include <WiFi.h> 
#include <WiFiUDP.h> 
#include <math.h> 
// Wi-Fi credentials 
const char* ssid = "Velcia"; 
const char* password = "yten7128"; 
// UDP setup 
WiFiUDP udp; 
unsigned int localUdpPort = 4210; 
char incomingPacket[255]; 
// Ultrasonic sensor pins 
#define TRIG_PIN 5 
#define ECHO_PIN 18 
// Motor control pins (L298N) 
#define IN1 25 
#define IN2 26 
#define IN3 32 
#define IN4 33 
// Optional: PWM speed control (if not jumpered) 
#define ENA 27 
#define ENB 14 
// LED and buzzer 
#define LED_PIN 21 
#define BUZZER_PIN 22
// Fixed receiver GPS location (hardcoded) 
float receiverLat = 12.9077285; // <-- Replace with actual lat 
float receiverLon = 77.5653293; 
// <-- Replace with actual lon 
// Distance thresholds 
float obstacleThresholdCM = 30.0; 
float proximityThresholdM = 5.0; 
// Data from transmitter 
bool transmitterBraking = false; 
float transmitterLat = 0.0; 
float transmitterLon = 0.0; 
float obstacleDistance = 100.0; 
void setup() { 
Serial.begin(115200); 
delay(1000); 
// Wi-Fi 
WiFi.begin(ssid, password); 
Serial.print("Connecting to Wi-Fi"); 
while (WiFi.status() != WL_CONNECTED) { 
delay(500); Serial.print("."); 
} 
Serial.println("\nWi-Fi connected"); 
Serial.println("\nWi-Fi connected!"); 
Serial.print("ESP32 IP Address: "); 
Serial.println(WiFi.localIP()); 
udp.begin(localUdpPort); 
// Pins 
pinMode(TRIG_PIN, OUTPUT); 
pinMode(ECHO_PIN, INPUT); 
pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT); 
pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT); 
pinMode(ENA, OUTPUT); pinMode(ENB, OUTPUT); 
pinMode(LED_PIN, OUTPUT); 
pinMode(BUZZER_PIN, OUTPUT); 
stopMotors(); 
} 
void loop() { 
checkUltrasonic(); 
receiveData(); 
float distanceToTransmitter = haversine(receiverLat, receiverLon, transmitterLat, 
transmitterLon); 
Serial.print("Distance to transmitter: "); 
Serial.print(distanceToTransmitter); 
Serial.println(" meters"); 
// Logic 
if (obstacleDistance < obstacleThresholdCM) { 
Serial.println("ðŸš« Obstacle ahead â€” STOP"); 
stopMotors(); 
digitalWrite(LED_PIN, 
HIGH); 
digitalWrite(BUZZER_PIN, HIGH); 
} else { 
if (distanceToTransmitter <= proximityThresholdM) { 
Serial.println("âœ… Transmitter close â€” MOVE"); 
moveForward(); 
digitalWrite(LED_PIN, LOW); 
digitalWrite(BUZZER_PIN, LOW); 
} else { 
Serial.println("ðŸš« Transmitter far â€” STOP"); 
stopMotors(); 
digitalWrite(LED_PIN, LOW); 
digitalWrite(BUZZER_PIN, LOW); 
} 
} 
delay(300); 
} 
// --- Ultrasonic distance calculation --- 
void checkUltrasonic() { 
digitalWrite(TRIG_PIN, LOW); delayMicroseconds(2); 
digitalWrite(TRIG_PIN, HIGH); delayMicroseconds(10); 
digitalWrite(TRIG_PIN, LOW); 
long duration = pulseIn(ECHO_PIN, HIGH, 30000); 
obstacleDistance = duration * 0.034 / 2.0; 
Serial.print("Obstacle distance: "); 
Serial.print(obstacleDistance); 
Serial.println(" cm"); 
} 
// --- UDP receive and parse --- 
void receiveData() { 
int packetSize = udp.parsePacket(); 
if (packetSize) { 
int len = udp.read(incomingPacket, 255); 
if (len > 0) { 
incomingPacket[len] = 0; 
String data = String(incomingPacket); 
parseTransmitterData(data); 
} 
} 
} 
void parseTransmitterData(String data) { 
int latIndex = data.indexOf("\"lat\":"); 
int lonIndex = data.indexOf("\"lon\":"); 
int brakeIndex = data.indexOf("\"brake\":"); 
if (latIndex != -1 && lonIndex != -1 && brakeIndex != -1) { 
transmitterLat = data.substring(latIndex + 6, data.indexOf(",", latIndex)).toFloat(); 
transmitterLon = data.substring(lonIndex + 6, data.indexOf(",", lonIndex)).toFloat(); 
transmitterBraking = data.indexOf("true", brakeIndex) != -1; 
} 
} 
// --- Haversine formula to compute GPS distance (meters) --- 
float haversine(float lat1, float lon1, float lat2, float lon2) { 
const float R = 6371000; // Earth radius in meters 
float dLat = radians(lat2 - lat1); 
float dLon = radians(lon2 - lon1); 
float a = sin(dLat / 2) * sin(dLat / 2) + 
cos(radians(lat1)) * cos(radians(lat2)) * 
sin(dLon / 2) * sin(dLon / 2); 
float c = 2 * atan2(sqrt(a), sqrt(1 - a)); 
return R * c; 
} 
// --- Motor Control --- 
void moveForward() { 
digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW); // Left forward 
digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW); // Right forward 
analogWrite(ENA, 200); // Speed control (0-255) 
analogWrite(ENB, 200); 
} 
void stopMotors() { 
digitalWrite(IN1, LOW); digitalWrite(IN2, LOW); 
digitalWrite(IN3, LOW); digitalWrite(IN4, LOW); 
analogWrite(ENA, 0); 
analogWrite(ENB, 0); 
}

